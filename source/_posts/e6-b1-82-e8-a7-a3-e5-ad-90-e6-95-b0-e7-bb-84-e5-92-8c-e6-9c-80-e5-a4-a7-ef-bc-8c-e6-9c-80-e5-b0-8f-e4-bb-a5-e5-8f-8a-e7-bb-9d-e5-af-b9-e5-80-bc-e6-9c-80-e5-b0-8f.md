---
title: 求解子数组和最大，最小以及绝对值最小
id: 524
categories:
  - 学习
date: 2014-11-12 00:12:02
tags:
---

在一个数组中求解字数组最大是一个经典的问题，详见[Maximum subarray problem](http://en.wikipedia.org/wiki/Maximum_subarray_problem)
python代码实现如下

[python]
def max_subarray(A):
    max_ending_here = max_so_far = A[0]
    for x in A[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
[/python]

我封装成面向对象的C++风格算法，如下

[cpp]
//
//  Array.h
//  cppplayground
//
//  Created by Liudonghua on 11/11/14.
//  Copyright (c) 2014 Liudonghua. All rights reserved.
//

#ifndef cppplayground_Array_h
#define cppplayground_Array_h

#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;initializer_list&gt;

using namespace std;

template &lt;typename T&gt;
class Array
{
private:
    vector&lt;T&gt; mData;

public:
    Array();
    // copy constructor
    Array(Array&lt;T&gt; const&amp; array);
    // move constructor
    Array(Array&lt;T&gt; const&amp;&amp; array);
    // http://stackoverflow.com/questions/26391745/custom-array-class-constructor-for-initialization-of-list
    // initializer_list
    Array(initializer_list&lt;T&gt; il);
    virtual ~Array();

    // operator overload
    // http://stackoverflow.com/questions/4660123/overloading-friend-operator-for-template-class/4661372#4661372
    template &lt;typename U&gt;
    friend istream&amp; operator&gt;&gt;(istream&amp; is, Array&lt;U&gt;&amp; array);
    template &lt;typename U&gt;
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, Array&lt;U&gt; const&amp; array);
    // copy assignment operator
    Array&lt;T&gt;&amp; operator=(Array&lt;T&gt; const&amp; rhs);
    // move assignment operator
    Array&lt;T&gt;&amp; operator=(Array&lt;T&gt; const&amp;&amp; rhs);
    Array&lt;T&gt; operator*(T multiple);

    T maxSummedSubArrayValue();
    T minSummedSubArrayValue();
    T minAbsoluteSummedSubArrayValue();

};

template &lt;typename T&gt;
Array&lt;T&gt;::Array():mData(vector&lt;T&gt;()) {

}

template &lt;typename T&gt;
Array&lt;T&gt;::Array(Array&lt;T&gt; const&amp; array) {
    //this-&gt;mData = vector&lt;T&gt;(array.mData);
    this-&gt;mData = vector&lt;T&gt;(array.mData.size());
    copy(array.mData.begin(), array.mData.end(), this-&gt;mData.begin());
}

template &lt;typename T&gt;
Array&lt;T&gt;::Array(Array&lt;T&gt; const&amp;&amp; array) {
    *this = move(array);
}

template &lt;typename T&gt;
Array&lt;T&gt;::Array(initializer_list&lt;T&gt; il) {
    unsigned long initializer_list_size = il.size();
    this-&gt;mData = vector&lt;T&gt;(initializer_list_size);
    auto begin = this-&gt;mData.begin();
    for (T const&amp; i : il) {
        *begin++ = i;
    }
}

template &lt;typename T&gt;
Array&lt;T&gt;::~Array() {

}

// http://stackoverflow.com/questions/236129/split-a-string-in-c
template &lt;typename U&gt;
istream&amp; operator&gt;&gt;(istream&amp; is, Array&lt;U&gt;&amp; array) {
    string inputString;
    getline(is, inputString);
    U data;
    stringstream ss(inputString);
    while(ss &gt;&gt; data) {
        array.mData.push_back(data);
    }
    return is;
}

template &lt;typename U&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, Array&lt;U&gt; const&amp; array) {
    for (auto begin = array.mData.begin(), end = array.mData.end(); begin != end; ++begin) {
        os &lt;&lt; *begin &lt;&lt; &quot; &quot;;
    }
    os &lt;&lt; endl;
    return os;
}

template &lt;typename T&gt;
Array&lt;T&gt;&amp; Array&lt;T&gt;::operator=(Array&lt;T&gt; const&amp; rhs) {
    if (this != &amp;rhs) {
        this-&gt;mData = vector&lt;T&gt;(rhs.mData);
    }
    return *this;
}

template &lt;typename T&gt;
Array&lt;T&gt;&amp; Array&lt;T&gt;::operator=(Array&lt;T&gt; const&amp;&amp; rhs) {
    if (this != &amp;rhs) {
        this-&gt;mData = move(rhs.mData);
    }
    return *this;
}

template &lt;typename T&gt;
Array&lt;T&gt; Array&lt;T&gt;::operator*(T multiple) {
    Array&lt;T&gt; multipledArray;
    multipledArray.mData = vector&lt;T&gt;(this-&gt;mData);
    for (auto begin = multipledArray.mData.begin(); begin != multipledArray.mData.end(); ++begin) {
        *begin = multiple * (*begin);
    }
    return multipledArray;
}

// http://en.wikipedia.org/wiki/Maximum_subarray_problem
template &lt;typename T&gt;
T Array&lt;T&gt;::maxSummedSubArrayValue() {
    T maxEndingHere = mData[0], maxSoFar = mData[0];
    for (int i = 1; i &lt; mData.size(); ++i) {
        T x = mData[i];
        maxEndingHere = max&lt;T&gt;(x, maxEndingHere + x);
        maxSoFar = max&lt;T&gt;(maxSoFar, maxEndingHere);
    }
    return maxSoFar;
}

template &lt;typename T&gt;
T Array&lt;T&gt;::minSummedSubArrayValue() {
    T minEndingHere = mData[0], minSoFar = mData[0];
    for (int i = 1; i &lt; mData.size(); ++i) {
        T x = mData[i];
        minEndingHere = min&lt;T&gt;(x, minEndingHere + x);
        minSoFar = min&lt;T&gt;(minSoFar, minEndingHere);
    }
    return minSoFar;
}

template &lt;typename T&gt;
T Array&lt;T&gt;::minAbsoluteSummedSubArrayValue() {
    // generate incremental array
    vector&lt;T&gt; incrementalData = vector&lt;T&gt;();
    T summedTmp = 0;
    for(int i = 0; i &lt; mData.size(); ++i) {
        for(int j = 0; j &lt;= i; ++j) {
            summedTmp += mData[j];
        }
        incrementalData.push_back(summedTmp);
        summedTmp = 0;
    }
    // sort the incremental array
    sort(incrementalData.begin(), incrementalData.end());
    // calculate minimum diff
    T minAbsoluteDiff = incrementalData[0];
    for(auto begin = incrementalData.begin() + 1, end = incrementalData.end(); begin != end; ++begin) {
        if(abs(*begin - *(begin -1)) &lt; abs(minAbsoluteDiff)) {
            minAbsoluteDiff = *begin - *(begin -1);
        }
    }
    return minAbsoluteDiff;
}

#endif
[/cpp]

<del>不过求最小绝对值还有问题，待更新！！！</del>
最小绝对值已解决

注：此类包含了一些我实验C++11、14特性的东西，可能不完善或存在一定问题（待更新）