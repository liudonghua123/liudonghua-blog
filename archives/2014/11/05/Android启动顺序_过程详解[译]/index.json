{"summary":"<p>在<a href=\"http://www.kpbird.com/2012/11/in-depth-android-boot-sequence-process.html\" target=\"_blank\" rel=\"noopener\">这里</a>看到一篇关于Android启动过程的文章，讲的还是不错，为了加深理解和分享这方面的知识，所以就翻译了一下。</p>\n<a id=\"more\"></a>\n<p>当我按了Android手机的电源键发生了什么？<br>Android启动顺序是什么样的？<br>什么是Linux内核？<br>桌面Linux内核和Android内核有什么区别？<br>什么是bootloader？<br>什么是Zygote？<br>什么是x86和ARM Linux？<br>什么是init.rc？<br>什么是System Server？</p>\n<p>当我在思考Android启动过程时，很多这样的问题萦绕在我脑海里。</p>\n<p>我将在这里解释Android系统过程，我希望你能找到以上问题的答案。</p>\n<p>[toc]</p>\n<p>Android是基于开源的Linux系统，<a href=\"http://en.wikipedia.org/wiki/X86\" target=\"_blank\" rel=\"noopener\">x86</a>（x86是基于Intel 8086 CPU的一系列电脑微处理器指令集架构）是Linux内核使用最多的架构，但是Android设备通常运行在<a href=\"http://en.wikipedia.org/wiki/ARM\" target=\"_blank\" rel=\"noopener\">ARM</a>处理器（ARM是Advanced RISC Machine或之前的Acorn RISC Machine的简称）上，<a href=\"http://xolo.in/xolo-x900-features\" target=\"_blank\" rel=\"noopener\">Intel Xolo</a>设备除外。Xolo装备有Atom 1.6GHz x86处理器。Android启动顺序或嵌入式设备或基于ARM的Linux系统相比桌面Linux有一些区别。在这篇文章里，我将只讲解Android的启动顺序，<a href=\"http://www.ibm.com/developerworks/linux/library/l-linuxboot/\" target=\"_blank\" rel=\"noopener\">Linux启动进程</a>是一篇讲解桌面Linux启动顺序的好文章。</p>\n<p>Android设备但你按开机键之后又如下启动阶段<br><a href=\"/resources/2014/11/Android-Boot-Squence.png\"><img src=\"/resources/2014/11/Android-Boot-Squence.png\" alt=\"Android Boot Squence\"></a></p>\n<h1 id=\"阶段1：开机和系统初始化\"><a href=\"#阶段1：开机和系统初始化\" class=\"headerlink\" title=\"阶段1：开机和系统初始化\"></a>阶段1：开机和系统初始化</h1><p>当开机时，从预先定义好即硬写在ROM里的Boot ROM代码开始执行，加载Bootloader到RAM里，然后开始执行Bootloader</p>\n<h1 id=\"阶段2：Bootloader启动加载器\"><a href=\"#阶段2：Bootloader启动加载器\" class=\"headerlink\" title=\"阶段2：Bootloader启动加载器\"></a>阶段2：Bootloader启动加载器</h1><p>Bootloader是一个很小的程序在启动Android系统之前运行，它是第一个运行的程序，所以会对主板和处理器而专门编写。设备制造商使用一些主流的bootloader例如<a href=\"http://ecos.sourceware.org/redboot/\" target=\"_blank\" rel=\"noopener\">redboot</a>,<a href=\"http://www.denx.de/wiki/U-Boot\" target=\"_blank\" rel=\"noopener\">uboot</a>, <a href=\"http://wiki.openmoko.org/wiki/Qi\" target=\"_blank\" rel=\"noopener\">qi bootloader</a>或他们自己开发的。这不是Android系统的一部分，通常OEM或运营商可以在这里面添加锁或一些限制</p>\n<p>Bootloader的运行有两个阶段，第一阶段：检测外部RAM和加载帮助第二阶段的程序；第二阶段：设置网络，内存等运行内核所必须的环境，bootloader还能提供运行kernel特定的参数或输入来完成特殊任务</p>\n<p>Android bootloader代码位于</p>\n<p><android source=\"\">\\bootable\\bootloader\\legacy\\usbloader<br>legacy loader含有两个主要的文件</android></p>\n<ol>\n<li>init.s 初始化stacks、对BSS段清零，调用main.c中的_main()</li>\n<li>main.c 初始化硬件（时钟、主板、键盘、控制台），创建Linux tags</li>\n</ol>\n<p>参考以下链接了解更多Android bootloader内容<br><a href=\"https://motorola-global-portal.custhelp.com/app/answers/detail/a_id/86208/~/bootloader-frequently-asked-questions\" target=\"_blank\" rel=\"noopener\">https://motorola-global-portal.custhelp.com/app/answers/detail/a_id/86208/~/bootloader-frequently-asked-questions</a></p>\n<h1 id=\"阶段3：内核\"><a href=\"#阶段3：内核\" class=\"headerlink\" title=\"阶段3：内核\"></a>阶段3：内核</h1><p>Android内核的运行类似于桌面Linux内核，当启动内核时，设置缓存、保留的内存，调度，加载驱动程序。当内核启动完成的第一件事就是找到init程序，然后以root权限运行这个系统进程</p>\n<h1 id=\"阶段4：init进程\"><a href=\"#阶段4：init进程\" class=\"headerlink\" title=\"阶段4：init进程\"></a>阶段4：init进程</h1><p>Init是一个最先运行的进程，我们可以说是根进程或所有其他进程的父进程。Init进程有两个任务，挂载/sys,/dev,/proc文件系统和运行init.rc脚本</p>\n<p>init可以在这里找到/system/core/init<br>inti.rc可以在这里找到/system/core/rootdir/init.rc<br>readme.txt在这里/system/core/init/readme.txt</p>\n<p>Android的init.rc有特殊的格式和规则，他们是Actions、Commands、Services、Options</p>\n<p>语法<br>on <trigger></trigger></p>\n<p><command></p>\n<p><command></p>\n<command>\n\n<p>Service : Services是由init启动，当退出时可能会重启</p>\n<p>service <name> <pathname> [ <argument> ]*</argument></pathname></name></p>\n<p><option></option></p>\n<p><option><br>…</option></p>\n<p>Options : Options是Service的参数，影响service如何以及怎样运行</p>\n<p>让我们看一下默认的init.rc文件，这里我只列出了主要的events和services<br><a href=\"/resources/2014/11/init.rc_action_service.png\"><img src=\"/resources/2014/11/init.rc_action_service.png\" alt=\"init.rc_action_service\"></a><br>这个阶段，你可以在屏幕上看到Android的logo</p>\n<h1 id=\"阶段5：Zygote-and-Dalvik\"><a href=\"#阶段5：Zygote-and-Dalvik\" class=\"headerlink\" title=\"阶段5：Zygote and Dalvik\"></a>阶段5：Zygote and Dalvik</h1><p>在Java里，我们知道对于每个不同的程序Java虚拟器启动不同的实例来运行，为了让Android应用启动的尽可能快，如果每个程序都使用一个JVM则会消耗很多内存和时间，所以为了克服这个问题，Android系统有一个能在Dalvik虚拟机中共享运行代码，低内存消耗，快速启动的Zygote，Zygote预加载、初始化一些Android SDK或Core Framework的，只读的系统核心库。在虚拟机的每个实例中都有一份核心库和堆对象</p>\n<p>Zygote加载过程</p>\n<ol>\n<li>加载<a href=\"http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/2.2_r1.1/com/android/internal/os/ZygoteInit.java\" target=\"_blank\" rel=\"noopener\">Zygote</a>类<br><android source=\"\">/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</android></li>\n<li>registerZygoteSocket() - 为zygote命令连接注册一个server socket</li>\n<li>preloadClasses() - “preloaded-classes” 是一个含有需要预加载的类的文本文件，可以在这里找到 <android source=\"\">/frameworks/base</android></li>\n<li>preloadResources() - preloadResources即原生主题和布局，包括android.R，这些都将通过这个方法加载</li>\n</ol>\n<p>这时你可以看到启动动画</p>\n<h1 id=\"阶段6：System-Service或简称为Services\"><a href=\"#阶段6：System-Service或简称为Services\" class=\"headerlink\" title=\"阶段6：System Service或简称为Services\"></a>阶段6：System Service或简称为Services</h1><p>当完成了以上阶段，系统会请求Zygote启动用原生语言或Java开发的system servers，system servers可以认为是进程，system server作为Android SDK的System Services使用的，system server包含system services</p>\n<p>Core Services:</p>\n<ol>\n<li>Starting Power Manager</li>\n<li>Creating Activity Manager</li>\n<li>Starting Telephony Registry</li>\n<li>Starting Package Manager</li>\n<li>Set Activity Manager Service as System Process</li>\n<li>Starting Context Manager</li>\n<li>Starting System Context Providers</li>\n<li>Starting Battery Service</li>\n<li>Starting Alarm Manager<br>10.Starting Sensor Service<br>11.Starting Window Manager<br>12.Starting Bluetooth Service<br>13.Starting Mount Service</li>\n</ol>\n<p>Other services</p>\n<ol>\n<li>Starting Status Bar Service</li>\n<li>Starting Hardware Service</li>\n<li>Starting NetStat Service</li>\n<li>Starting Connectivity Service</li>\n<li>Starting Notification Manager</li>\n<li>Starting DeviceStorageMonitor Service</li>\n<li>Starting Location Manager</li>\n<li>Starting Search Service</li>\n<li>Starting Clipboard Service<br>10.Starting Checkin Service<br>11.Starting Wallpaper Service<br>12.Starting Audio Service<br>13.Starting HeadsetObserver<br>14.Starting AdbSettingsObserver</li>\n</ol>\n<h1 id=\"阶段7-启动完成\"><a href=\"#阶段7-启动完成\" class=\"headerlink\" title=\"阶段7 :  启动完成\"></a>阶段7 :  启动完成</h1><p>一旦System Services在内存中启动后，Android就完成了启动过程，这时”ACTION_BOOT_COMPLETED”标准广播就会触发</p>\n<p>了解相关更多内容可参考<br><a href=\"http://stackoverflow.com/questions/22455153/what-is-the-need-of-second-stage-boot-loader-why-different-bootloaders-like-fi\" target=\"_blank\" rel=\"noopener\">what is the need of second stage boot loader ? why different bootloaders like first stage and second stage?</a><br><a href=\"http://elinux.org/Android_Booting\" target=\"_blank\" rel=\"noopener\">Android_Booting</a><br><a href=\"https://github.com/jollen/android-ota/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">Android OTA 介紹</a><br><a href=\"http://blog.csdn.net/zjujoe/article/details/6206010\" target=\"_blank\" rel=\"noopener\">Android OTA 升级之一：编译升级包</a> 系列文章</p>\n"}